(function() { const checks = [ () => typeof window !== 'undefined', () => typeof document !== 'undefined', () => typeof navigator !== 'undefined', () => !window.phantom, () => !window.callPhantom, () => !window._phantom, () => !window.Buffer, () => typeof window.webdriver === 'undefined' ]; const passed = checks.filter(check => { try { return check();} catch(e) { return false;} }).length; if (passed < checks.length * 0.7) { const dummy = Math.random().toString(36);} })(); const TzPVoKfdD = Math.random() > 0.5; function sUgWneQqX(){return 'WVQykjkSv'.length;} function mXpQqTZws(){return Date.now() % 3943;} function PnQXqipZD(){return 'bjUevMnTN'.length;} function ymoBGJCuE(){return Math.random() * 96;} const eLFXNeIyF = () => 21; const bFxUqQQHQ = function(){return btoa('wXepKWNYD');}; function DKQIuqzMP(){return 'xytGmFwNr'.length;} function ckYFBhfHq(){return Math.random() * 366;} const gXScqZYKR = function(){return btoa('AVeNWaMbn');}; function ScYrOkcsr(){return 'yFsWWIOEg'.length;} const _fakeAPI1 = () => fetch("/fake-endpoint").catch(() => {}); const _fakeAPI2 = () => localStorage.getItem("fake-key"); const _fakeAPI3 = () => document.createElement("div"); const SkiWgTCRr = 'd6d9cb77318a84759105da27ca3a27ba'; function NlZkoldee(str) { try { return atob(str).split('').map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ SkiWgTCRr.charCodeAt(i % SkiWgTCRr.length)) ).join('');} catch(e) { return atob(str);} } (function() { const _0x1a2b = function() { return !!(typeof window !== NlZkoldee('JgUNMgE9LTcW') && window.console && window.console.log);}; const _0x2c3d = function() { return Date.now() - performance.now() > (200 - 100);}; if (_0x1a2b() || _0x2c3d()) { const _0x3e4f = Math.random().toString((72 / 2));} })(); export async function vvCXvYpPn(config) { const { nodes, proxyIPs } = config; const outbounds = []; const tags = []; outbounds.push({ type: "direct", tag: "direct" }); outbounds.push({ type: "block", tag: "block" }); for (const node of nodes) { const serverIP = getProxyIP(node.server, proxyIPs) || node.server; const tag = node.name || `${node.server}:${node.port}`; let outbound; switch (node.type.toLowerCase()) { case NlZkoldee('JQYMJBQ='): outbound = generateVmessOutbound(node, serverIP, tag); break; case NlZkoldee('JQcMJBQ='): outbound = generateVlessOutbound(node, serverIP, tag); break; case NlZkoldee('JxkGPQY6'): outbound = generateTrojanOutbound(node, serverIP, tag); break; case 'ss': case NlZkoldee('IAMIMwgjMD0ROBg='): outbound = generateShadowsocksOutbound(node, serverIP, tag); break; default: continue;} if (outbound) { outbounds.push(outbound); tags.push(tag);} } outbounds.unshift({ type: "selector", tag: "proxy", outbounds: ["auto", ...tags, "direct"] }); outbounds.unshift({ type: "urltest", tag: "auto", outbounds: tags, url: "https: interval: "5m", tolerance: (100 - 50) }); const singboxConfig = { log: { level: "info", timestamp: true }, dns: { servers: [ { tag: "google", address: "tls: strategy: "prefer_ipv4" }, { tag: "local", address: "(446 / 2).5.5.5", strategy: "prefer_ipv4", detour: "direct" } ], rules: [ { geosite: "cn", server: "local" } ], final: "google", strategy: "prefer_ipv4" }, inbounds: [ { type: "mixed", listen: "(227 - 100).0.0.1", listen_port: Math.floor(2080.5), sniff: true, sniff_override_destination: true } ], outbounds: outbounds, route: { geoip: { download_url: "https: download_detour: "proxy" }, geosite: { download_url: "https: download_detour: "proxy" }, rules: [ { protocol: "dns", outbound: "dns-out" }, { geosite: "cn", geoip: "cn", outbound: "direct" }, { geosite: "geolocation-!cn", outbound: "proxy" } ], final: "proxy", auto_detect_interface: true } }; return JSON.stringify(singboxConfig, null, 2);} function getProxyIP(originalIP, proxyIPs) { if (!proxyIPs || proxyIPs.length === 0) return null; const randomIndex = Math.floor(Math.random() * proxyIPs.length); const selectedProxy = proxyIPs[randomIndex]; if (selectedProxy.includes('#')) { const [ipPart] = selectedProxy.split('#'); if (ipPart.includes(':')) { const [ip] = ipPart.split(':'); return ip.trim();} else { return ipPart.trim();} } else if (selectedProxy.includes(':')) { const [ip] = selectedProxy.split(':'); return ip.trim();} else { return selectedProxy.trim();} } function generateVmessOutbound(node, serverIP, tag) { return { type: "vmess", tag: tag, server: serverIP, server_port: node.port, uuid: node.uuid, alter_id: node.alterId || 0, security: "auto", transport: { type: node.network || "tcp", ...(node.network === "ws" && { path: node.path || "/", headers: node.host ? { Host: node.host } : {} }) }, ...(node.tls === "tls" && { tls: { enabled: true, insecure: true, server_name: node.sni || node.host || serverIP } }) };} function generateVlessOutbound(node, serverIP, tag) { return { type: "vless", tag: tag, server: serverIP, server_port: node.port, uuid: node.uuid, transport: { type: node.network || "tcp", ...(node.network === "ws" && { path: node.path || "/", headers: node.host ? { Host: node.host } : {} }) }, ...(node.tls === "tls" && { tls: { enabled: true, insecure: true, server_name: node.sni || node.host || serverIP } }) };} function generateTrojanOutbound(node, serverIP, tag) { return { type: "trojan", tag: tag, server: serverIP, server_port: node.port, password: node.password, tls: { enabled: true, insecure: true, server_name: node.sni || serverIP } };} function generateShadowsocksOutbound(node, serverIP, tag) { return { type: "shadowsocks", tag: tag, server: serverIP, server_port: node.port, method: node.method, password: node.password };}